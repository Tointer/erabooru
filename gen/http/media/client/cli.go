// Code generated by goa v3.21.1, DO NOT EDIT.
//
// media HTTP client CLI support package
//
// Command:
// $ goa gen era/booru/design

package client

import (
	"encoding/json"
	media "era/booru/gen/media"
	"fmt"
	"strconv"
)

// BuildListPayload builds the payload for the media list endpoint from CLI
// flags.
func BuildListPayload(mediaListQ string, mediaListPage string, mediaListPageSize string) (*media.ListPayload, error) {
	var err error
	var q *string
	{
		if mediaListQ != "" {
			q = &mediaListQ
		}
	}
	var page *int
	{
		if mediaListPage != "" {
			var v int64
			v, err = strconv.ParseInt(mediaListPage, 10, strconv.IntSize)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var pageSize *int
	{
		if mediaListPageSize != "" {
			var v int64
			v, err = strconv.ParseInt(mediaListPageSize, 10, strconv.IntSize)
			val := int(v)
			pageSize = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for pageSize, must be INT")
			}
		}
	}
	v := &media.ListPayload{}
	v.Q = q
	v.Page = page
	v.PageSize = pageSize

	return v, nil
}

// BuildPreviewsPayload builds the payload for the media previews endpoint from
// CLI flags.
func BuildPreviewsPayload(mediaPreviewsQ string, mediaPreviewsPage string, mediaPreviewsPageSize string) (*media.PreviewsPayload, error) {
	var err error
	var q *string
	{
		if mediaPreviewsQ != "" {
			q = &mediaPreviewsQ
		}
	}
	var page *int
	{
		if mediaPreviewsPage != "" {
			var v int64
			v, err = strconv.ParseInt(mediaPreviewsPage, 10, strconv.IntSize)
			val := int(v)
			page = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for page, must be INT")
			}
		}
	}
	var pageSize *int
	{
		if mediaPreviewsPageSize != "" {
			var v int64
			v, err = strconv.ParseInt(mediaPreviewsPageSize, 10, strconv.IntSize)
			val := int(v)
			pageSize = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for pageSize, must be INT")
			}
		}
	}
	v := &media.PreviewsPayload{}
	v.Q = q
	v.Page = page
	v.PageSize = pageSize

	return v, nil
}

// BuildGetPayload builds the payload for the media get endpoint from CLI flags.
func BuildGetPayload(mediaGetID string) (*media.GetPayload, error) {
	var id string
	{
		id = mediaGetID
	}
	v := &media.GetPayload{}
	v.ID = id

	return v, nil
}

// BuildUploadURLPayload builds the payload for the media uploadURL endpoint
// from CLI flags.
func BuildUploadURLPayload(mediaUploadURLBody string) (*media.UploadURLPayload, error) {
	var err error
	var body struct {
		Filename *string `form:"filename" json:"filename" xml:"filename"`
	}
	{
		err = json.Unmarshal([]byte(mediaUploadURLBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"filename\": \"In quis tempore culpa quibusdam.\"\n   }'")
		}
	}
	v := &media.UploadURLPayload{}
	if body.Filename != nil {
		v.Filename = *body.Filename
	}

	return v, nil
}

// BuildUpdateTagsPayload builds the payload for the media updateTags endpoint
// from CLI flags.
func BuildUpdateTagsPayload(mediaUpdateTagsBody string, mediaUpdateTagsID string) (*media.UpdateTagsPayload, error) {
	var err error
	var body struct {
		Tags []string `form:"tags" json:"tags" xml:"tags"`
	}
	{
		err = json.Unmarshal([]byte(mediaUpdateTagsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"tags\": [\n         \"Doloribus laborum.\",\n         \"Deserunt qui corrupti nihil commodi minima consequatur.\"\n      ]\n   }'")
		}
	}
	var id string
	{
		id = mediaUpdateTagsID
	}
	v := &media.UpdateTagsPayload{}
	if body.Tags != nil {
		v.Tags = make([]string, len(body.Tags))
		for i, val := range body.Tags {
			v.Tags[i] = val
		}
	}
	v.ID = id

	return v, nil
}

// BuildDeletePayload builds the payload for the media delete endpoint from CLI
// flags.
func BuildDeletePayload(mediaDeleteID string) (*media.DeletePayload, error) {
	var id string
	{
		id = mediaDeleteID
	}
	v := &media.DeletePayload{}
	v.ID = id

	return v, nil
}
